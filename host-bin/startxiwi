#!/bin/sh -e
# Copyright (c) 2015 The crouton Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

set -e

APPLICATION="${0##*/}"
OPTS_ENTER=''
OPTS_XIWI=''

USAGE="$APPLICATION [options] chroot_app [parameters]

Wraps enter-chroot to launch a window or tab in Chromium OS for any graphical application.
Applications launched in this way show in independent windows or tabs.

By default, it will use the primary user on the first xiwi-enabled chroot found and launch
the chroot_app in a window.

    -b          Fork and run the specified command silently in the background.
    -c CHROOTS  Directory the chroots are in. Default: /usr/local/chroots
    -f          Prevent xiwi from quitting automatically.[1]
    -h          Help with $APPLICATION options, with brief explanations.
    -k KEYFILE  Override the auto-detected encryption key location.
    -n NAME     Name of the chroot to enter. Default: first one found in CHROOTS
    -t TARGET   Only enter the chroot if it contains the specified TARGET.
    -u USERNAME Username (or UID) to log into. Default: 1000 (the primary user)
    -F          Launch the chroot_app full-screen.
    -T          Launch the chroot_app in a tab.

    [1] xiwi will normally close when the application returns. Some gui applications
        fork before or during normal operation, which can confuse xiwi and cause it to
        quit prematurely. If your application does not have a parameter that prevents
        it from forking, and crouton is unable to automatically detect the fork, you can
        use -f to prevent xiwi from quitting automatically.
        xiwi will quit if you close the Chromium OS window when nothing is displayed.
  
    You can cycle through multiple windows inside the
    application via Ctrl-Alt-Tab/Ctrl-Alt-Shift-Tab, or close them via
    Ctrl-Alt-Shift-Escape.  If the chroot_app begins with 'start' but you still want to
    use the default window manager, specify the full path of the application.
"

# Exits the script with exit code $1, spitting out message $@ to stderr
error() {
    local ecode="$1"
    shift
    echo "$*" 1>&2
    exit "$ecode"
}

options='bc:fhk:n:t:u:FT'
while getopts $options OPT; do
    case ${OPT} in
      b) OPTS_ENTER="$OPTS_ENTER -${OPT}";;
      c|k|n|t|u) for param in "$OPTARG"; do
                     opts_enter="$opts_enter'$(echo -n "$param" | sed "s/'/'\\\\\\''/g")'"
                     opts_enter="$(echo -n "$opts_enter" | sed -e "s/^ //" -e "s/'//g")"
                 done
                 OPTS_ENTER="$OPTS_ENTER -${OPT} ${opts_enter}";;
      h) error 2 "$USAGE";;
      f|F|T) OPTS_XIWI="$OPTS_XIWI -${OPT}";;
      ?) error 2 "$USAGE";;
    esac
done
shift "$((OPTIND-1))"

eval "exec sh -e '`dirname "\`readlink -f "$0"\`"`/enter-chroot' -t xiwi $OPTS_ENTER \
      exec xiwi $OPTS_XIWI \"\$@\"" \
     || ret=$?

exit $ret
