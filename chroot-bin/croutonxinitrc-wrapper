#!/bin/sh -e
# Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# xinitrc wrapper for crouton:
#  1. Runs crouton-specific commands
#  2. Runs the provided client (emulating xinit behaviour)
#  3. Runs crouton-specific commands before the server is destroyed

cmd=''
extraargs=''
binary=''

# This part is a translation of what is found in xorg's xinit.c

if [ -z "$1" ] || [ "${1#[/.]}" = "$1" ]; then
    # No client parameter: find .xinitrc if possible, run xterm otherwise
    required=''

    if [ -n "$XINITRC" ]; then
        cmd="$XINITRC"
        required='y'
    elif [ -n "$HOME" ]; then
        cmd="$HOME/.xinitrc"
    fi

    if [ ! -e "$cmd" ]; then
        if [ -n "$required" ]; then
            echo "Warning, no client init file \"$cmd\"" 1>&2
        fi

        # If no client is given, use default command
        cmd="xterm"
        extraargs="-geometry +1+1 -n login"
        # Make sure xterm is executed directly: let sh resolve the path
        binary='y'
    fi
else
    cmd="$1"
    shift
fi

# Run crouton-specific commands:

# Record the name of the chroot in the root window properties
if [ -f '/etc/crouton/name' ] && hash xprop 2>/dev/null; then
    xprop -root -f CROUTON_NAME 8s -set CROUTON_NAME "`cat '/etc/crouton/name'`"
fi

# Launch the powerd poker daemon
croutonpowerd --daemon &

# Launch the clipboard synchronization daemon
if hash croutonclip 2>/dev/null; then
    croutonclip &
fi

# Apply the Chromebook keyboard map if installed.
if [ -f '/usr/share/X11/xkb/compat/chromebook' ]; then
    setxkbmap -model chromebook
fi

# Launch key binding daemon
xmethod="`readlink -f '/etc/X11/xinit/xserverrc'`"
xmethod="${xmethod##*-}"

XMETHOD="$xmethod" xbindkeys -fg /etc/crouton/xbindkeysrc.scm

# Launch xbindkeys for the Chromium OS X server if it isn't running
mkdir -m 775 -p /tmp/crouton-lock
{
    # Only let one instance *really* run at a time
    flock 3
    XMETHOD='' host-x11 xbindkeys -n -fg /etc/crouton/xbindkeysrc.scm
} 3>/tmp/crouton-lock/xbindkeys &

# Pass through the host cursor and correct mousewheels on xephyr
if [ "$xmethod" = 'xephyr' ]; then
    host-x11 croutoncursor "$DISPLAY" &
    if [ -z "$CROUTON_WHEEL_PARAMS" -a -r "$HOME/.croutonwheel" ]; then
        CROUTON_WHEEL_PARAMS="`head -n1 "$HOME/.croutonwheel"`"
    fi
    croutonwheel $CROUTON_WHEEL_PARAMS &
fi

# Launch touchegg if it is requested.
toucheggconf='/etc/touchegg.conf'
if [ -f "$toucheggconf" ]; then
    mkdir -p "$HOME/.config/touchegg"
    ln -sf "$toucheggconf" "$HOME/.config/touchegg/"
    touchegg 2>/dev/null &
fi

# Configure trackpad settings if needed
if synclient >/dev/null 2>&1; then
    case "`awk -F= '/_RELEASE_BOARD=/{print $2}' '/var/host/lsb-release'`" in
        butterfly*|falco*) SYNCLIENT="FingerLow=1 FingerHigh=5 $SYNCLIENT";;
        parrot*|peppy*) SYNCLIENT="FingerLow=5 FingerHigh=10 $SYNCLIENT";;
    esac
    if [ -n "$SYNCLIENT" ]; then
        synclient $SYNCLIENT
    fi
fi

# Shell is the leader of a process group, so signals sent to this process are
# propagated to its children. We ignore signals in this process, but the child
# handles them and exits. This process then runs exit commands, and terminates.
trap "" HUP INT TERM

# Run the client itself if it is executable, otherwise run it in a shell.
ret=0
if [ -n "$binary" -o -x "$cmd" ]; then
    "$cmd" $extraargs "$@" || ret=$?
else
    /bin/sh "$cmd" $extraargs "$@" || ret=$?
fi

trap - HUP INT TERM

# Run crouton-specific commands before the server exits:

echo "Running exit commands..." 1>&2

# Restore framebuffer compression if there are no other non-Chromium X servers
fbc='/sys/module/i915/parameters/i915_enable_fbc'
if [ -w "$fbc" ]; then
    # There is at least 2 servers running (the current one and Chromium OS)
    if [ "`ps -CX -CXorg -CXephyr -opid= | wc -l`" -le 2 ]; then
        echo 1 > "$fbc"
    fi
fi

exit "$ret"
